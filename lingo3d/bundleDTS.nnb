{
    "cells": [
        {
            "language": "typescript",
            "source": [
                "import fs from \"fs\";\nimport path from \"path\";\n\nconst normalizeDTS = (value: string, parent: Record<string, any>) => {\n  if (value.endsWith(\".d.ts\")) return value;\n  const test = value + \".d.ts\";\n  if (test in parent) return test;\n  return value;\n};\n\nconst fileTree: Record<string, any> = {};\n\nconst parentNodeMap = new WeakMap<Record<string, any>, Record<string, any>>();\nconst nodePathMap = new WeakMap<Record<string, any>, string>();\nconst makeNode = (parent: Record<string, any>, path: string) => {\n  const result: Record<string, any> = {};\n  parentNodeMap.set(result, parent);\n  nodePathMap.set(result, path);\n  return result;\n};\n\ntype FileNode = {\n  isFileNode: true;\n  modulePath: string;\n  name: string;\n  text: string;\n};\n\nconst isFileNode = (target: any): target is FileNode => target.isFileNode;\n\nconst rootPath =\n  \"/Users/lai/Documents/files.noindex/GitHub/lingo3d/lingo3d/lib\";\nconst rootPathPartsLength = rootPath.split(\"/\").length - 1;\n\nconst aggregate = (pathArray: Array<string>, iEnd: number) => {\n  let result = \"\";\n  for (let i = rootPathPartsLength; i <= iEnd; ++i)\n    result += pathArray[i] + \"/\";\n  result = result.slice(0, -1);\n  return result;\n};\n\nconst set = (\n  obj: Record<string, any>,\n  pathArray: Array<string>,\n  value: FileNode\n) => {\n  let target = obj;\n  const iMax = pathArray.length - 1;\n  for (let i = 0; i < iMax; ++i)\n    target = target[pathArray[i]] ??= makeNode(target, aggregate(pathArray, i));\n  target[pathArray[iMax]] = value;\n  parentNodeMap.set(value, target);\n  nodePathMap.set(value, aggregate(pathArray, iMax));\n};\n\nconst loopThroughFiles = (directoryPath: string) => {\n  for (const file of fs.readdirSync(directoryPath)) {\n    const filePath = path.join(directoryPath, file);\n    const stats = fs.statSync(filePath);\n    if (stats.isDirectory()) {\n      loopThroughFiles(filePath);\n      continue;\n    }\n    const parts = filePath.split(\"/\");\n    parts.shift();\n    set(fileTree, parts, {\n      isFileNode: true,\n      modulePath: filePath.slice(rootPath.length + 1),\n      name: file,\n      text: fs.readFileSync(filePath, \"utf8\"),\n    });\n  }\n};\nloopThroughFiles(rootPath);\n\nconst dtsFiles: Array<FileNode> = [];\nconst traverse = (node: Record<string, any>) => {\n  for (const file of Object.values(node))\n    if (isFileNode(file)) file.name.endsWith(\".d.ts\") && dtsFiles.push(file);\n    else traverse(file);\n};\ntraverse(fileTree);\n\nconst modules = new Map<string, string>();\nconst imports = new Set<string>();\nfor (const dtsFile of dtsFiles) {\n  //@ts-ignore\n  dtsFile.text = dtsFile.text.replaceAll(\"declare \", \"\");\n\n  const matches = dtsFile.text.match(/ from \"\\..*\"/g);\n  const delimiters = /(\\.\\.\\/|\\.\\/|\\/)/;\n\n  for (let match of matches ?? []) {\n    let parts = match.slice(7, -1).split(delimiters);\n    parts.shift();\n    parts = parts.filter((p) => p && p !== \"/\");\n\n    let current: Record<string, any> = parentNodeMap.get(dtsFile)!;\n    for (let i = 0; i < parts.length; ++i) {\n      const part =\n        i === parts.length - 1 ? normalizeDTS(parts[i], current) : parts[i];\n      if (part === \"../\" || part === \"..\") {\n        current = parentNodeMap.get(current)!;\n      } else if (part === \"./\" || part === \".\") {\n        current = current;\n      } else {\n        current = current[part];\n      }\n    }\n    const resolved = \"lib/\" + nodePathMap.get(current)!;\n    const importPath = `bundle/${\n      resolved.endsWith(\".d.ts\")\n        ? resolved.slice(0, -5)\n        : resolved.endsWith(\"/\")\n        ? resolved.slice(0, -1)\n        : resolved\n    }`;\n    dtsFile.text = dtsFile.text.replace(match, ` from \"${importPath}\"`);\n    imports.add(importPath);\n  }\n\n  let modulePath = `bundle/lib/${dtsFile.modulePath.slice(0, -5)}`;\n  if (dtsFile.modulePath.endsWith(\"index.d.ts\"))\n    modulePath = modulePath.slice(0, -6);\n  modules.set(\n    modulePath,\n    `declare module \"${modulePath}\" {\\n${dtsFile.text}}\\n`\n  );\n}\n\nconst prunedModules: Array<string> = [];\nfor (const importPath of imports) {\n  if (!modules.has(importPath)) {\n    console.log(importPath);\n    throw new Error();\n  }\n  prunedModules.push(modules.get(importPath)!);\n}\n\nlet bundle = \"\";\nfor (const module of prunedModules) bundle += module;\n\nfs.writeFileSync(\n  \"/Users/lai/Documents/files.noindex/GitHub/lingo3d/lingo3d/public/assets/editor/lingo3d.d.ts\",\n  bundle,\n  \"utf8\"\n);\n\nconsole.log(\"done\");\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "done",
                                ""
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}