{
    "cells": [
        {
            "language": "typescript",
            "source": [
                "import fs from \"fs\";\nimport path from \"path\";\n\nconst normalizeDTS = (value: string) =>\n  value.endsWith(\".d.ts\") ? value : value + \".d.ts\";\n\nconst fileTree: Record<string, any> = {};\n\nconst parentNodeMap = new WeakMap<Record<string, any>, Record<string, any>>();\nconst nodeNameMap = new WeakMap<Record<string, any>, string>();\nconst makeNode = (parent: Record<string, any>, name: string) => {\n  const result: Record<string, any> = {};\n  parentNodeMap.set(result, parent);\n  nodeNameMap.set(result, name);\n  return result;\n};\n\ntype FileNode = {\n  isFileNode: true;\n  path: string;\n  name: string;\n  text: string;\n};\n\nconst isFileNode = (target: any): target is FileNode => target.isFileNode;\n\nconst set = (\n  obj: Record<string, any>,\n  path: Array<string>,\n  value: FileNode\n) => {\n  let target = obj;\n  const iMax = path.length - 1;\n  for (let i = 0; i < iMax; ++i)\n    target = target[path[i]] ??= makeNode(target, path[i]);\n  target[path[iMax]] = value;\n  parentNodeMap.set(value, target);\n  nodeNameMap.set(value, path[iMax]);\n};\n\nconst loopThroughFiles = (directoryPath: string) => {\n  for (const file of fs.readdirSync(directoryPath)) {\n    const filePath = path.join(directoryPath, file);\n    const stats = fs.statSync(filePath);\n    if (stats.isDirectory()) {\n      loopThroughFiles(filePath);\n      continue;\n    }\n    const parts = filePath.split(\"/\");\n    parts.shift();\n\n    set(fileTree, parts, {\n      isFileNode: true,\n      path: filePath,\n      name: file,\n      text: fs.readFileSync(filePath, \"utf8\"),\n    });\n  }\n};\n\nloopThroughFiles(\n  \"/Users/lai/Documents/files.noindex/GitHub/lingo3d/lingo3d/lib\"\n);\n\nconst dtsFiles: Array<FileNode> = [];\nconst traverse = (node: Record<string, any>) => {\n  for (const file of Object.values(node))\n    if (isFileNode(file)) {\n      file.name.endsWith(\".d.ts\") && dtsFiles.push(file);\n    } else traverse(file);\n};\ntraverse(fileTree);\n\nlet bundle = \"\";\nfor (const dtsFile of dtsFiles) {\n  const matches = dtsFile.text.match(/ from \"\\..*\"/g);\n  const delimiters = /(\\.\\.\\/|\\.\\/|\\/)/;\n\n  for (let match of matches ?? []) {\n    let parts = match.slice(7, -1).split(delimiters);\n    parts.shift();\n    parts = parts.filter((p) => p && p !== \"/\");\n\n    let current: Record<string, any> = parentNodeMap.get(dtsFile)!;\n    let resolved = \"\";\n    for (let i = 0; i < parts.length; ++i) {\n      const isLast = i === parts.length - 1;\n      const part = isLast ? normalizeDTS(parts[i]) : parts[i];\n      if (part === \"../\") current = parentNodeMap.get(current)!;\n      else if (part === \"./\") current = current;\n      else current = current[part];\n\n      resolved += nodeNameMap.get(current)!;\n      if (!isLast) resolved += \"/\";\n    }\n    dtsFile.text = dtsFile.text.replace(\n      match,\n      ` from \"bundle/${resolved.slice(0, -5)}\"`\n    );\n  }\n\n  bundle += `declare module \"bundle/${dtsFile.name.slice(0, -5)}\" {\\n${\n    dtsFile.text\n  }}\\n`;\n}\n\nconsole.log(bundle);\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                " from \"../display/core/Appendable\"",
                                " from \"../display/core/MeshAppendable\"",
                                "_______________",
                                "declare module \"bundle/root\" {",
                                "import Appendable from \"bundle/lib/display/core/Appendable\";",
                                "import MeshAppendable from \"bundle/lib/display/core/MeshAppendable\";",
                                "declare class Root extends Appendable {",
                                "    constructor();",
                                "    children: Set<Appendable | MeshAppendable<import(\"three\").Object3D<import(\"three\").Event>>>;",
                                "    traverse: (cb: (appendable: Appendable | MeshAppendable) => void) => void;",
                                "    traverseSome: (cb: (appendable: Appendable | MeshAppendable) => unknown) => boolean;",
                                "    append(child: Appendable | MeshAppendable): void;",
                                "    attach(child: Appendable | MeshAppendable): void;",
                                "    protected disposeNode(): void;",
                                "}",
                                "declare const _default: Root;",
                                "export default _default;",
                                "}",
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}