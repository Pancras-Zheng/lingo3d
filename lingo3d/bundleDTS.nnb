{
    "cells": [
        {
            "language": "typescript",
            "source": [
                "import fs from \"fs\";\nimport path from \"path\";\n\nconst normalizeDTS = (value: string) =>\n  value.endsWith(\".d.ts\") ? value : value + \".d.ts\";\n\nconst fileTree: Record<string, any> = {};\n\nconst parentNodeMap = new WeakMap<Record<string, any>, Record<string, any>>();\nconst nodeNameMap = new WeakMap<Record<string, any>, string>();\nconst makeNode = (parent: Record<string, any>, name: string) => {\n  const result: Record<string, any> = {};\n  parentNodeMap.set(result, parent);\n  nodeNameMap.set(result, name);\n  return result;\n};\n\ntype FileNode = {\n  isFileNode: true;\n  modulePath: string;\n  name: string;\n  text: string;\n};\n\nconst isFileNode = (target: any): target is FileNode => target.isFileNode;\n\nconst set = (\n  obj: Record<string, any>,\n  path: Array<string>,\n  value: FileNode\n) => {\n  let target = obj;\n  const iMax = path.length - 1;\n  for (let i = 0; i < iMax; ++i)\n    target = target[path[i]] ??= makeNode(target, path[i]);\n  target[path[iMax]] = value;\n  parentNodeMap.set(value, target);\n  nodeNameMap.set(value, path[iMax]);\n};\n\nconst loopThroughFiles = (directoryPath: string, rootPath = directoryPath) => {\n  for (const file of fs.readdirSync(directoryPath)) {\n    const filePath = path.join(directoryPath, file);\n    const stats = fs.statSync(filePath);\n    if (stats.isDirectory()) {\n      loopThroughFiles(filePath, rootPath);\n      continue;\n    }\n    const parts = filePath.split(\"/\");\n    parts.shift();\n\n    set(fileTree, parts, {\n      isFileNode: true,\n      modulePath: filePath.slice(rootPath.length + 1),\n      name: file,\n      text: fs.readFileSync(filePath, \"utf8\"),\n    });\n  }\n};\n\nloopThroughFiles(\n  \"/Users/lai/Documents/files.noindex/GitHub/lingo3d/lingo3d/lib\"\n);\n\nconst dtsFiles: Array<FileNode> = [];\nconst traverse = (node: Record<string, any>) => {\n  for (const file of Object.values(node))\n    if (isFileNode(file)) {\n      file.name.endsWith(\".d.ts\") && dtsFiles.push(file);\n    } else traverse(file);\n};\ntraverse(fileTree);\n\nconst modules = new Map<string, string>();\nconst imports = new Set<string>();\nfor (const dtsFile of dtsFiles) {\n  //@ts-ignore\n  dtsFile.text = dtsFile.text.replaceAll(\"declare \", \"\");\n\n  const matches = dtsFile.text.match(/ from \"\\..*\"/g);\n  const delimiters = /(\\.\\.\\/|\\.\\/|\\/)/;\n\n  for (let match of matches ?? []) {\n    let parts = match.slice(7, -1).split(delimiters);\n    parts.shift();\n    parts = parts.filter((p) => p && p !== \"/\");\n\n    let current: Record<string, any> = parentNodeMap.get(dtsFile)!;\n    let resolved = \"\";\n    for (let i = 0; i < parts.length; ++i) {\n      const isLast = i === parts.length - 1;\n      const part = isLast ? normalizeDTS(parts[i]) : parts[i];\n      if (part === \"../\") current = parentNodeMap.get(current)!;\n      else if (part === \"./\") current = current;\n      else current = current[part];\n\n      resolved += nodeNameMap.get(current)!;\n      if (!isLast) resolved += \"/\";\n    }\n    const importPath = `bundle/${resolved.slice(0, -5)}`;\n    dtsFile.text = dtsFile.text.replace(match, ` from \"${importPath}\"`);\n    imports.add(importPath);\n  }\n\n  const modulePath = `bundle/lib/${dtsFile.modulePath.slice(0, -5)}`;\n  modules.set(\n    modulePath,\n    `declare module \"${modulePath}\" {\\n${dtsFile.text}}\\n`\n  );\n}\n\nconst prunedModules: Array<string> = []\nfor (const importPath of imports) {\n  prunedModules.push(modules.get(importPath)!)\n}\n\nlet bundle = \"\";\nfor (const module of prunedModules) bundle += module;\n\nfs.writeFileSync(\n  \"/Users/lai/Documents/files.noindex/GitHub/lingo3d/lingo3d/public/assets/editor/lingo3d.d.ts\",\n  bundle,\n  \"utf8\"\n);\n\nconsole.log(\"done\");\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "done",
                                ""
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}